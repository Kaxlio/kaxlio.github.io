
<!DOCTYPE html>
<html lang="zh-cn">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>

  
  <meta charset="UTF-8">
  <title>
    我的第一篇文章 | CVE日报
  </title>


  
  <meta name="viewport" content="width=device-width,user-scalable=no,maximum-scale=1,initial-scale=1">

  
  <link rel="canonical" href="http://localhost:1313/post/2024-02-28-cve/"/>

  
  <link rel="stylesheet" href="/css/sanitize.css">
  <link rel="stylesheet" href="/css/responsive.css">
  <link rel="stylesheet" href="/css/highlight_monokai.css">
  <link rel="stylesheet" href="/css/theme.css">
  <link rel="stylesheet" href="/css/custom.css">
  
  
  <link href="http://localhost:1313/index.xml" rel="alternate" type="application/rss+xml" title="CVE日报" />
  <link href="http://localhost:1313/index.xml" rel="feed" type="application/rss+xml" title="CVE日报" />

  
  


</head>



<body>
<div class="container">

  
  <header role="banner">
    <div class="row gutters">
      <div id="site-title" class="col span_6">
        <h1><a href="http://localhost:1313/">CVE日报</a></h1>
        
      </div>
      <div id="social" class="col span_6">
        <ul>
          
          
          
          
        </ul>
      </div>
    </div>
  </header>


  
  <main id="single" role="main">
    <div class="article-header">
      <h1>我的第一篇文章</h1>
      <div class="meta">
        Nov 20, 2022 &nbsp;
        
      </div>
    </div>
    <article>
      <!-- raw HTML omitted -->
<h2 id="new_entries">New_entries</h2>
<h3 id="cve-2021-46904">CVE-2021-46904</h3>
<h4 id="description">description</h4>
<p>In the Linux kernel, the following vulnerability has been resolved: net: hso: fix null-ptr-deref during tty device unregistration Multiple ttys try to claim the same the minor number causing a double unregistration of the same device. The first unregistration succeeds but the next one results in a null-ptr-deref. The get_free_serial_index() function returns an available minor number but doesnt assign it immediately. The assignment is done by the caller later. But before this assignment, calls to get_free_serial_index() would return the same minor number. Fix this by modifying get_free_serial_index to assign the minor number immediately after one is found to be and rename it to obtain_minor() to better reflect what it does. Similary, rename set_serial_by_index() to release_minor() and modify it to free up the minor number of the given hso_serial. Every obtain_minor() should have corresponding release_minor() call.</p>
<h4 id="description-1">description</h4>
<p>在Linux内核中，已解决以下漏洞：net:hso:fix在tty设备注销期间修复null ptr deref多个tty试图声明相同的次要编号，导致同一设备双重注销。第一次注销成功，但下一次注销会导致ptr defef为空。get_free_serial_index（）函数返回一个可用的次要数字，但不会立即赋值。该分配稍后由调用方完成。但在此赋值之前，对get_free_serial_index（）的调用将返回相同的次要数字。通过修改get_free_serial_index来解决这个问题，在发现一个后立即分配次要编号，并将其重命名为获取次要编号（），以更好地反映它的作用。类似地，将set_serial_by_index（）重命名为release_minor（），并对其进行修改以释放给定hso_serial的次要编号。每个获取minor（）都应该有相应的release_minor（）调用。</p>
<table>
<thead>
<tr>
<th>cvss</th>
<th>epss</th>
<th>percentile</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>0.04%</td>
<td>10.59%</td>
</tr>
</tbody>
</table>
<h4 id="references">references</h4>
<ul>
<li><a href="https://git.kernel.org/stable/c/145c89c441d27696961752bf51b323f347601bee">https://git.kernel.org/stable/c/145c89c441d27696961752bf51b323f347601bee</a></li>
<li><a href="https://git.kernel.org/stable/c/388d05f70f1ee0cac4a2068fd295072f1a44152a">https://git.kernel.org/stable/c/388d05f70f1ee0cac4a2068fd295072f1a44152a</a></li>
<li><a href="https://git.kernel.org/stable/c/4a2933c88399c0ebc738db39bbce3ae89786d723">https://git.kernel.org/stable/c/4a2933c88399c0ebc738db39bbce3ae89786d723</a></li>
<li><a href="https://git.kernel.org/stable/c/8a12f8836145ffe37e9c8733dce18c22fb668b66">https://git.kernel.org/stable/c/8a12f8836145ffe37e9c8733dce18c22fb668b66</a></li>
<li><a href="https://git.kernel.org/stable/c/92028d7a31e55d53e41cff679156b9432cffcb36">https://git.kernel.org/stable/c/92028d7a31e55d53e41cff679156b9432cffcb36</a></li>
<li><a href="https://git.kernel.org/stable/c/a462067d7c8e6953a733bf5ade8db947b1bb5449">https://git.kernel.org/stable/c/a462067d7c8e6953a733bf5ade8db947b1bb5449</a></li>
<li><a href="https://git.kernel.org/stable/c/caf5ac93b3b5d5fac032fc11fbea680e115421b4">https://git.kernel.org/stable/c/caf5ac93b3b5d5fac032fc11fbea680e115421b4</a></li>
<li><a href="https://git.kernel.org/stable/c/dc195928d7e4ec7b5cfc6cd10dc4c8d87a7c72ac">https://git.kernel.org/stable/c/dc195928d7e4ec7b5cfc6cd10dc4c8d87a7c72ac</a></li>
</ul>
<h3 id="cve-2021-46905">CVE-2021-46905</h3>
<h4 id="description-2">description</h4>
<p>In the Linux kernel, the following vulnerability has been resolved: net: hso: fix NULL-deref on disconnect regression Commit 8a12f8836145 (&ldquo;net: hso: fix null-ptr-deref during tty device unregistration&rdquo;) fixed the racy minor allocation reported by syzbot, but introduced an unconditional NULL-pointer dereference on every disconnect instead. Specifically, the serial device table must no longer be accessed after the minor has been released by hso_serial_tty_unregister().</p>
<h4 id="description-3">description</h4>
<p>在Linux内核中，已解决以下漏洞：net:hso:fix NULL deref on disconnect regression Commit 8a12f8836145（“net:hso:fix NULL ptr deref during tty device unregistration”）修复了syzbot报告的racy次要分配，但在每次断开连接时引入了无条件的NULL指针取消引用。具体而言，在hso_serial_tty_unregister（）释放次要设备后，不得再访问串行设备表。</p>
<table>
<thead>
<tr>
<th>cvss</th>
<th>epss</th>
<th>percentile</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>0.04%</td>
<td>8.10%</td>
</tr>
</tbody>
</table>
<h4 id="references-1">references</h4>
<ul>
<li><a href="https://git.kernel.org/stable/c/0f000005da31f6947f843ce6b3e3a960540c6e00">https://git.kernel.org/stable/c/0f000005da31f6947f843ce6b3e3a960540c6e00</a></li>
<li><a href="https://git.kernel.org/stable/c/2ad5692db72874f02b9ad551d26345437ea4f7f3">https://git.kernel.org/stable/c/2ad5692db72874f02b9ad551d26345437ea4f7f3</a></li>
<li><a href="https://git.kernel.org/stable/c/41c44e1f3112d7265dae522c026399b2a42d19ef">https://git.kernel.org/stable/c/41c44e1f3112d7265dae522c026399b2a42d19ef</a></li>
<li><a href="https://git.kernel.org/stable/c/5c17cfe155d21954b4c7e2a78fa771cebcd86725">https://git.kernel.org/stable/c/5c17cfe155d21954b4c7e2a78fa771cebcd86725</a></li>
<li><a href="https://git.kernel.org/stable/c/90642ee9eb581a13569b1c0bd57e85d962215273">https://git.kernel.org/stable/c/90642ee9eb581a13569b1c0bd57e85d962215273</a></li>
<li><a href="https://git.kernel.org/stable/c/d7fad2ce15bdbbd0fec3ebe999fd7cab2267f53e">https://git.kernel.org/stable/c/d7fad2ce15bdbbd0fec3ebe999fd7cab2267f53e</a></li>
</ul>
<h3 id="cve-2022-48626">CVE-2022-48626</h3>
<h4 id="description-4">description</h4>
<p>In the Linux kernel, the following vulnerability has been resolved: moxart: fix potential use-after-free on remove path It was reported that the mmc host structure could be accessed after it was freed in moxart_remove(), so fix this by saving the base register of the device and using it instead of the pointer dereference.</p>
<h4 id="description-5">description</h4>
<p>在Linux内核中，已解决以下漏洞：moxart:fix在remove path上释放后的潜在使用据报道，mmc主机结构在moxart_remove（）中释放后可以访问，因此通过保存设备的基寄存器并使用它而不是指针解引用来修复此问题。</p>
<table>
<thead>
<tr>
<th>cvss</th>
<th>epss</th>
<th>percentile</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>0.04%</td>
<td>10.59%</td>
</tr>
</tbody>
</table>
<h4 id="references-2">references</h4>
<ul>
<li><a href="https://git.kernel.org/stable/c/3a0a7ec5574b510b067cfc734b8bdb6564b31d4e">https://git.kernel.org/stable/c/3a0a7ec5574b510b067cfc734b8bdb6564b31d4e</a></li>
<li><a href="https://git.kernel.org/stable/c/7f901d53f120d1921f84f7b9b118e87e94b403c5">https://git.kernel.org/stable/c/7f901d53f120d1921f84f7b9b118e87e94b403c5</a></li>
<li><a href="https://git.kernel.org/stable/c/9c25d5ff1856b91bd4365e813f566cb59aaa9552">https://git.kernel.org/stable/c/9c25d5ff1856b91bd4365e813f566cb59aaa9552</a></li>
<li><a href="https://git.kernel.org/stable/c/af0e6c49438b1596e4be8a267d218a0c88a42323">https://git.kernel.org/stable/c/af0e6c49438b1596e4be8a267d218a0c88a42323</a></li>
<li><a href="https://git.kernel.org/stable/c/bd2db32e7c3e35bd4d9b8bbff689434a50893546">https://git.kernel.org/stable/c/bd2db32e7c3e35bd4d9b8bbff689434a50893546</a></li>
<li><a href="https://git.kernel.org/stable/c/be93028d306dac9f5b59ebebd9ec7abcfc69c156">https://git.kernel.org/stable/c/be93028d306dac9f5b59ebebd9ec7abcfc69c156</a></li>
<li><a href="https://git.kernel.org/stable/c/e6f580d0b3349646d4ee1ce0057eb273e8fb7e2e">https://git.kernel.org/stable/c/e6f580d0b3349646d4ee1ce0057eb273e8fb7e2e</a></li>
<li><a href="https://git.kernel.org/stable/c/f5dc193167591e88797262ec78515a0cbe79ff5f">https://git.kernel.org/stable/c/f5dc193167591e88797262ec78515a0cbe79ff5f</a></li>
</ul>
<h3 id="cve-2023-52465">CVE-2023-52465</h3>
<h4 id="description-6">description</h4>
<p>In the Linux kernel, the following vulnerability has been resolved: power: supply: Fix null pointer dereference in smb2_probe devm_kasprintf and devm_kzalloc return a pointer to dynamically allocated memory which can be NULL upon failure.</p>
<h4 id="description-7">description</h4>
<p>在Linux内核中，已解决以下漏洞：电源：修复smb2_probe devm_kasprintf中的空指针取消引用，devm_kzalloc返回一个指向动态分配内存的指针，该指针在失败时可能为空。</p>
<table>
<thead>
<tr>
<th>cvss</th>
<th>epss</th>
<th>percentile</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>0.04%</td>
<td>12.26%</td>
</tr>
</tbody>
</table>
<h4 id="references-3">references</h4>
<ul>
<li><a href="https://git.kernel.org/stable/c/88f04bc3e737155e13caddf0ba8ed19db87f0212">https://git.kernel.org/stable/c/88f04bc3e737155e13caddf0ba8ed19db87f0212</a></li>
<li><a href="https://git.kernel.org/stable/c/bd3d2ec447ede9da822addf3960a5f4275e3ae76">https://git.kernel.org/stable/c/bd3d2ec447ede9da822addf3960a5f4275e3ae76</a></li>
<li><a href="https://git.kernel.org/stable/c/e2717302fbc20f148bcda362facee0444b949a3a">https://git.kernel.org/stable/c/e2717302fbc20f148bcda362facee0444b949a3a</a></li>
</ul>
<h3 id="cve-2023-52466">CVE-2023-52466</h3>
<h4 id="description-8">description</h4>
<p>In the Linux kernel, the following vulnerability has been resolved: PCI: Avoid potential out-of-bounds read in pci_dev_for_each_resource() Coverity complains that pointer in the pci_dev_for_each_resource() may be wrong, i.e., might be used for the out-of-bounds read. There is no actual issue right now because we have another check afterwards and the out-of-bounds read is not being performed. In any case its better code with this fixed, hence the proposed change. As Jonas pointed out &ldquo;It probably makes the code slightly less performant as res will now be checked for being not NULL (which will always be true), but I doubt it will be significant (or in any hot paths).&rdquo;</p>
<h4 id="description-9">description</h4>
<p>在Linux内核中，已解决以下漏洞：PCI:避免PCI_dev_for_each_resource（）中潜在的越界读取。Coverity抱怨PCI_dev-for_each-resource（）的指针可能是错误的，即可能用于越界读取。现在没有实际问题，因为我们之后还有另一次检查，并且没有执行越界读取。在任何情况下，它的更好的代码与此固定，因此提出了更改。正如Jonas所指出的，“这可能会使代码的性能稍微降低，因为现在将检查res是否为NULL（这将始终是真的），但我怀疑它是否有意义（或在任何热路径中）。”</p>
<table>
<thead>
<tr>
<th>cvss</th>
<th>epss</th>
<th>percentile</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>0.04%</td>
<td>12.26%</td>
</tr>
</tbody>
</table>
<h4 id="references-4">references</h4>
<ul>
<li><a href="https://git.kernel.org/stable/c/3171e46d677a668eed3086da78671f1e4f5b8405">https://git.kernel.org/stable/c/3171e46d677a668eed3086da78671f1e4f5b8405</a></li>
<li><a href="https://git.kernel.org/stable/c/5b3e25efe16e06779a9a7c7610217c1b921ec179">https://git.kernel.org/stable/c/5b3e25efe16e06779a9a7c7610217c1b921ec179</a></li>
<li><a href="https://git.kernel.org/stable/c/bd26159dcaaa3e9a927070efd348e7ce7e5ee933">https://git.kernel.org/stable/c/bd26159dcaaa3e9a927070efd348e7ce7e5ee933</a></li>
</ul>
<h3 id="cve-2023-52467">CVE-2023-52467</h3>
<h4 id="description-10">description</h4>
<p>In the Linux kernel, the following vulnerability has been resolved: mfd: syscon: Fix null pointer dereference in of_syscon_register() kasprintf() returns a pointer to dynamically allocated memory which can be NULL upon failure.</p>
<h4 id="description-11">description</h4>
<p>在Linux内核中，已解决以下漏洞：mfd:syscon:修复of_syscon_register（）中的空指针取消引用kasprintf（）返回一个指向动态分配内存的指针，该指针在失败时可能为null。</p>
<table>
<thead>
<tr>
<th>cvss</th>
<th>epss</th>
<th>percentile</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>0.04%</td>
<td>8.10%</td>
</tr>
</tbody>
</table>
<h4 id="references-5">references</h4>
<ul>
<li><a href="https://git.kernel.org/stable/c/3ef1130deee98997275904d9bfc37af75e1e906c">https://git.kernel.org/stable/c/3ef1130deee98997275904d9bfc37af75e1e906c</a></li>
<li><a href="https://git.kernel.org/stable/c/41673c66b3d0c09915698fec5c13b24336f18dd1">https://git.kernel.org/stable/c/41673c66b3d0c09915698fec5c13b24336f18dd1</a></li>
<li><a href="https://git.kernel.org/stable/c/527e8c5f3d00299822612c495d5adf1f8f43c001">https://git.kernel.org/stable/c/527e8c5f3d00299822612c495d5adf1f8f43c001</a></li>
<li><a href="https://git.kernel.org/stable/c/7f2c410ac470959b88e03dadd94b7a0b71df7973">https://git.kernel.org/stable/c/7f2c410ac470959b88e03dadd94b7a0b71df7973</a></li>
<li><a href="https://git.kernel.org/stable/c/927626a2073887ee30ba00633260d4d203f8e875">https://git.kernel.org/stable/c/927626a2073887ee30ba00633260d4d203f8e875</a></li>
<li><a href="https://git.kernel.org/stable/c/c3e3a2144bf50877551138ffce9f7aa6ddfe385b">https://git.kernel.org/stable/c/c3e3a2144bf50877551138ffce9f7aa6ddfe385b</a></li>
</ul>
<h3 id="cve-2023-52468">CVE-2023-52468</h3>
<h4 id="description-12">description</h4>
<p>In the Linux kernel, the following vulnerability has been resolved: class: fix use-after-free in class_register() The lock_class_key is still registered and can be found in lock_keys_hash hlist after subsys_private is freed in error handler path.A task who iterate over the lock_keys_hash later may cause use-after-free.So fix that up and unregister the lock_class_key before kfree(cp). On our platform, a driver fails to kset_register because of creating duplicate filename /class/xxx.With Kasan enabled, it prints a invalid-access bug report. KASAN bug report: BUG: KASAN: invalid-access in lockdep_register_key+0x19c/0x1bc Write of size 8 at addr 15ffff808b8c0368 by task modprobe/252 Pointer tag: [15], memory tag: [fe] CPU: 7 PID: 252 Comm: modprobe Tainted: G W 6.6.0-mainline-maybe-dirty #1 Call trace: dump_backtrace+0x1b0/0x1e4 show_stack+0x2c/0x40 dump_stack_lvl+0xac/0xe0 print_report+0x18c/0x4d8 kasan_report+0xe8/0x148 __hwasan_store8_noabort+0x88/0x98 lockdep_register_key+0x19c/0x1bc class_register+0x94/0x1ec init_module+0xbc/0xf48 [rfkill] do_one_initcall+0x17c/0x72c do_init_module+0x19c/0x3f8 &hellip; Memory state around the buggy address: ffffff808b8c0100: 8a 8a 8a 8a 8a 8a 8a 8a 8a 8a 8a 8a 8a 8a 8a 8a ffffff808b8c0200: 8a 8a 8a 8a 8a 8a 8a 8a fe fe fe fe fe fe fe fe &gt;ffffff808b8c0300: fe fe fe fe fe fe fe fe fe fe fe fe fe fe fe fe ^ ffffff808b8c0400: 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 As CONFIG_KASAN_GENERIC is not set, Kasan reports invalid-access not use-after-free here.In this case, modprobe is manipulating the corrupted lock_keys_hash hlish where lock_class_key is already freed before. Its worth noting that this only can happen if lockdep is enabled, which is not true for normal system.</p>
<h4 id="description-13">description</h4>
<p>在Linux内核中，已解决以下漏洞：class:fix在class_register（）中修复释放后使用。在错误处理程序路径中释放subsys_private后，lock_class_key仍在注册，并且可以在lock_keys_hash-hlist中找到。稍后迭代lock_keys_hash的任务可能会在释放后导致使用。因此，修复此问题并在kfree（cp）之前注销lock_class_key。在我们的平台上，由于创建了重复的filename/class/xxx，驱动程序无法kset_register。启用Kasan后，它会打印一份无效的访问错误报告。KASAN错误报告：bug:KASAN：lockdep_register_key+0x19c/0x1bc中的访问无效任务modprobe/252在地址15ffff808b8c0368写入大小为8的指针标记：[15]，内存标记：[fe]CPU:7 PID:252通信：modprobe已损坏：G W 6.6.0-主线-主机#1调用跟踪：dump_backtrace+0x1b0/0x1e4 show_stack+0x2c/0x40 dump_stack_lvl+0xac/0xe0 print_report+0x18c/0x4d8 kasan_report+0xe8/0x148 __hwasan_store8_noabort+0x88/0x98 lockdep_register_key+0x19c/0x1bc class_register+0x94/0x1ec init_module+0xbc/0xf48[rfkill]do_one_initcall+0x17c7c/0x72c do_init_module+0x19c/0x3f8。。。错误地址周围的内存状态：ffffff 808b8c0100:8a 8a 8a 8aa 8a 8a 8a 8c 8a fffffffff 808b8c0200:8a 8a8 8a 8a8 afe fe fe fe fe fe&gt;ffffffff 806b8c0300:fe fe fe ffe fe fe fe fi ^ ffffffoff 808b8c0400:03 03 03 03 01 03 03 03 04 03 03 03 05 03 03 03由于CONFIG_KASAN_GENERIC未设置，KASAN报告无效访问在此免费后不使用。在这种情况下，modprobe正在处理损坏的lock_keys_hash-hlish，其中lock_class_key之前已经释放。值得注意的是，只有在启用lockdep的情况下才会发生这种情况，而正常系统则不然。</p>
<table>
<thead>
<tr>
<th>cvss</th>
<th>epss</th>
<th>percentile</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>0.04%</td>
<td>12.26%</td>
</tr>
</tbody>
</table>
<h4 id="references-6">references</h4>
<ul>
<li><a href="https://git.kernel.org/stable/c/0f1486dafca3398c4c46b9f6e6452fa27e73b559">https://git.kernel.org/stable/c/0f1486dafca3398c4c46b9f6e6452fa27e73b559</a></li>
<li><a href="https://git.kernel.org/stable/c/93ec4a3b76404bce01bd5c9032bef5df6feb1d62">https://git.kernel.org/stable/c/93ec4a3b76404bce01bd5c9032bef5df6feb1d62</a></li>
<li><a href="https://git.kernel.org/stable/c/b57196a5ec5e4c0ffecde8348b085b778c7dce04">https://git.kernel.org/stable/c/b57196a5ec5e4c0ffecde8348b085b778c7dce04</a></li>
</ul>
<h3 id="cve-2023-52469">CVE-2023-52469</h3>
<h4 id="description-14">description</h4>
<p>In the Linux kernel, the following vulnerability has been resolved: drivers/amd/pm: fix a use-after-free in kv_parse_power_table When ps allocated by kzalloc equals to NULL, kv_parse_power_table frees adev-&gt;pm.dpm.ps that allocated before. However, after the control flow goes through the following call chains: kv_parse_power_table |-&gt; kv_dpm_init |-&gt; kv_dpm_sw_init |-&gt; kv_dpm_fini The adev-&gt;pm.dpm.ps is used in the for loop of kv_dpm_fini after its first free in kv_parse_power_table and causes a use-after-free bug.</p>
<h4 id="description-15">description</h4>
<p>在Linux内核中，已解决以下漏洞：drivers/amd/pm:修复kv_parse_power_table中释放后的使用当kzalloc分配的ps等于NULL时，kv_parse_prower_table释放之前分配的adev-&gt;pm.dpm.ps。然而，在控制流经过以下调用链之后：kv_parse_power_table |-&gt;kv_dpm_init|-&gt;kv_dpm_sw_init|-&gt;kv_dpm_fini在kv_parse_prower_table中首次释放后，adev-&gt;pm.dpm.ps在kv_dpm_fili的for循环中使用，并导致释放后使用错误。</p>
<table>
<thead>
<tr>
<th>cvss</th>
<th>epss</th>
<th>percentile</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>0.04%</td>
<td>10.59%</td>
</tr>
</tbody>
</table>
<h4 id="references-7">references</h4>
<ul>
<li><a href="https://git.kernel.org/stable/c/28dd788382c43b330480f57cd34cde0840896743">https://git.kernel.org/stable/c/28dd788382c43b330480f57cd34cde0840896743</a></li>
<li><a href="https://git.kernel.org/stable/c/3426f059eacc33ecc676b0d66539297e1cfafd02">https://git.kernel.org/stable/c/3426f059eacc33ecc676b0d66539297e1cfafd02</a></li>
<li><a href="https://git.kernel.org/stable/c/35fa2394d26e919f63600ce631e6aefc95ec2706">https://git.kernel.org/stable/c/35fa2394d26e919f63600ce631e6aefc95ec2706</a></li>
<li><a href="https://git.kernel.org/stable/c/520e213a0b97b64735a13950e9371e0a5d7a5dc3">https://git.kernel.org/stable/c/520e213a0b97b64735a13950e9371e0a5d7a5dc3</a></li>
<li><a href="https://git.kernel.org/stable/c/8a27d9d9fc9b5564b8904c3a77a7dea482bfa34e">https://git.kernel.org/stable/c/8a27d9d9fc9b5564b8904c3a77a7dea482bfa34e</a></li>
<li><a href="https://git.kernel.org/stable/c/8b55b06e737feb2a645b0293ea27e38418876d63">https://git.kernel.org/stable/c/8b55b06e737feb2a645b0293ea27e38418876d63</a></li>
<li><a href="https://git.kernel.org/stable/c/95084632a65d5c0d682a83b55935560bdcd2a1e3">https://git.kernel.org/stable/c/95084632a65d5c0d682a83b55935560bdcd2a1e3</a></li>
<li><a href="https://git.kernel.org/stable/c/b6dcba02ee178282e0d28684d241e0b8462dea6a">https://git.kernel.org/stable/c/b6dcba02ee178282e0d28684d241e0b8462dea6a</a></li>
</ul>
<h3 id="cve-2023-52470">CVE-2023-52470</h3>
<h4 id="description-16">description</h4>
<p>In the Linux kernel, the following vulnerability has been resolved: drm/radeon: check the alloc_workqueue return value in radeon_crtc_init() check the alloc_workqueue return value in radeon_crtc_init() to avoid null-ptr-deref.</p>
<h4 id="description-17">description</h4>
<p>在Linux内核中，已解决以下漏洞：drm/radeon：检查rade_crtc_init（）中的alloc_workqueue返回值检查rade_crtc_init（。</p>
<table>
<thead>
<tr>
<th>cvss</th>
<th>epss</th>
<th>percentile</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>0.04%</td>
<td>10.59%</td>
</tr>
</tbody>
</table>
<h4 id="references-8">references</h4>
<ul>
<li><a href="https://git.kernel.org/stable/c/0b813a6a0087451cb702b6eb841f10856f49d088">https://git.kernel.org/stable/c/0b813a6a0087451cb702b6eb841f10856f49d088</a></li>
<li><a href="https://git.kernel.org/stable/c/14bbfaa5df273b26cde6707f6e655585700e6fe1">https://git.kernel.org/stable/c/14bbfaa5df273b26cde6707f6e655585700e6fe1</a></li>
<li><a href="https://git.kernel.org/stable/c/21b1645660717d6126dd4866c850fcc5c4703a41">https://git.kernel.org/stable/c/21b1645660717d6126dd4866c850fcc5c4703a41</a></li>
<li><a href="https://git.kernel.org/stable/c/57ca7984806d79b38af528de88fd803babf27feb">https://git.kernel.org/stable/c/57ca7984806d79b38af528de88fd803babf27feb</a></li>
<li><a href="https://git.kernel.org/stable/c/5d12c5d75f7c78b83a738025947651ec5c95b4d4">https://git.kernel.org/stable/c/5d12c5d75f7c78b83a738025947651ec5c95b4d4</a></li>
<li><a href="https://git.kernel.org/stable/c/7a2464fac80d42f6f8819fed97a553e9c2f43310">https://git.kernel.org/stable/c/7a2464fac80d42f6f8819fed97a553e9c2f43310</a></li>
<li><a href="https://git.kernel.org/stable/c/c4ff55408187f2595066967047363ca84e76db85">https://git.kernel.org/stable/c/c4ff55408187f2595066967047363ca84e76db85</a></li>
<li><a href="https://git.kernel.org/stable/c/fb2d8bc9b5e55848b8a7c3c028e2ee8d49f28f97">https://git.kernel.org/stable/c/fb2d8bc9b5e55848b8a7c3c028e2ee8d49f28f97</a></li>
</ul>
<h3 id="cve-2023-52471">CVE-2023-52471</h3>
<h4 id="description-18">description</h4>
<p>In the Linux kernel, the following vulnerability has been resolved: ice: Fix some null pointer dereference issues in ice_ptp.c devm_kasprintf() returns a pointer to dynamically allocated memory which can be NULL upon failure.</p>
<h4 id="description-19">description</h4>
<p>在Linux内核中，以下漏洞已得到解决：ice：修复了ice_ptp中的一些空指针取消引用问题。c devm_kasprintf（）返回一个指向动态分配内存的指针，该指针在失败时可能为null。</p>
<table>
<thead>
<tr>
<th>cvss</th>
<th>epss</th>
<th>percentile</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>0.04%</td>
<td>6.87%</td>
</tr>
</tbody>
</table>
<h3 id="cve-2023-52472">CVE-2023-52472</h3>
<h4 id="description-20">description</h4>
<p>In the Linux kernel, the following vulnerability has been resolved: crypto: rsa - add a check for allocation failure Static checkers insist that the mpi_alloc() allocation can fail so add a check to prevent a NULL dereference. Small allocations like this cant actually fail in current kernels, but adding a check is very simple and makes the static checkers happy.</p>
<h4 id="description-21">description</h4>
<p>在Linux内核中，已解决以下漏洞：crypto:rsa-添加分配失败检查静态检查程序坚持认为mpi_alloc（）分配可能失败，因此添加检查以防止NULL解引用。在当前内核中，像这样的小分配实际上不会失败，但添加检查非常简单，可以让静态检查人员感到高兴。</p>
<table>
<thead>
<tr>
<th>cvss</th>
<th>epss</th>
<th>percentile</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>0.04%</td>
<td>12.26%</td>
</tr>
</tbody>
</table>
<h4 id="references-9">references</h4>
<ul>
<li><a href="https://git.kernel.org/stable/c/2831f4d3bfa68e64c5f83e96688be779c87b3511">https://git.kernel.org/stable/c/2831f4d3bfa68e64c5f83e96688be779c87b3511</a></li>
<li><a href="https://git.kernel.org/stable/c/95ad8b6879e2e49d02e3bfc0e1fb46421633fe2a">https://git.kernel.org/stable/c/95ad8b6879e2e49d02e3bfc0e1fb46421633fe2a</a></li>
<li><a href="https://git.kernel.org/stable/c/d872ca165cb67112f2841ef9c37d51ef7e63d1e4">https://git.kernel.org/stable/c/d872ca165cb67112f2841ef9c37d51ef7e63d1e4</a></li>
</ul>
<h3 id="cve-2023-52473">CVE-2023-52473</h3>
<h4 id="description-22">description</h4>
<p>In the Linux kernel, the following vulnerability has been resolved: thermal: core: Fix NULL pointer dereference in zone registration error path If device_register() in thermal_zone_device_register_with_trips() returns an error, the tz variable is set to NULL and subsequently dereferenced in kfree(tz-&gt;tzp). Commit adc8749b150c (&ldquo;thermal/drivers/core: Use put_device() if device_register() fails&rdquo;) added the tz = NULL assignment in question to avoid a possible double-free after dropping the reference to the zone device. However, after commit 4649620d9404 (&ldquo;thermal: core: Make thermal_zone_device_unregister() return after freeing the zone&rdquo;), that assignment has become redundant, because dropping the reference to the zone device does not cause the zone object to be freed any more. Drop it to address the NULL pointer dereference.</p>
<h4 id="description-23">description</h4>
<p>在Linux内核中，已解决以下漏洞：thermal:core：修复区域注册错误路径中的NULL指针取消引用。如果thermal_zone_device_register_with_trips（）中的device_register（）返回错误，则tz变量设置为NULL，随后在kfree中取消引用（tz-&gt;tzp）。提交adc8749b150c（“thermal/drivers/core：如果device_register（）失败，请使用put_device（）”）添加了有问题的tz=NULL赋值，以避免在删除对区域设备的引用后可能出现双重空闲。但是，在提交4649620d9404（“thermal:core：使thermal_zone_device_unregister（）在释放区域后返回”）之后，该分配已变得多余，因为删除对区域设备的引用不会再释放区域对象。将其删除以解决NULL指针取消引用的问题。</p>
<table>
<thead>
<tr>
<th>cvss</th>
<th>epss</th>
<th>percentile</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>0.04%</td>
<td>12.26%</td>
</tr>
</tbody>
</table>
<h4 id="references-10">references</h4>
<ul>
<li><a href="https://git.kernel.org/stable/c/02871710b93058eb1249d5847c0b2d1c2c3c98ae">https://git.kernel.org/stable/c/02871710b93058eb1249d5847c0b2d1c2c3c98ae</a></li>
<li><a href="https://git.kernel.org/stable/c/04e6ccfc93c5a1aa1d75a537cf27e418895e20ea">https://git.kernel.org/stable/c/04e6ccfc93c5a1aa1d75a537cf27e418895e20ea</a></li>
<li><a href="https://git.kernel.org/stable/c/335176dd8ebaca6493807dceea33c478305667fa">https://git.kernel.org/stable/c/335176dd8ebaca6493807dceea33c478305667fa</a></li>
</ul>
<h3 id="cve-2024-0435">CVE-2024-0435</h3>
<h4 id="description-24">description</h4>
<p>User can send a chat that contains an XSS opportunity that will then run when the chat is sent and on subsequent page loads. Given the minimum requirement for a user to send a chat is to be given access to a workspace via an admin the risk is low. Additionally, the location in which the XSS renders is only limited to the user who submits the XSS. Ultimately, this attack is limited to the user attacking themselves. There is no anonymous chat submission unless the user does not take the minimum steps required to protect their instance.</p>
<h4 id="description-25">description</h4>
<p>用户可以发送包含XSS机会的聊天，该机会将在发送聊天时运行，并在随后的页面加载中运行。考虑到用户发送聊天的最低要求是通过管理员访问工作空间，风险很低。此外，XSS呈现的位置仅限于提交XSS的用户。最终，这种攻击仅限于用户攻击自己。除非用户没有采取保护其实例所需的最低步骤，否则不会提交匿名聊天。</p>
<table>
<thead>
<tr>
<th>cvss</th>
<th>epss</th>
<th>percentile</th>
</tr>
</thead>
<tbody>
<tr>
<td>8.1 HIGH</td>
<td>None</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="references-11">references</h4>
<ul>
<li><a href="https://github.com/mintplex-labs/anything-llm/commit/a4ace56a401ffc8ce0082d7444159dfd5dc28834">https://github.com/mintplex-labs/anything-llm/commit/a4ace56a401ffc8ce0082d7444159dfd5dc28834</a></li>
<li><a href="https://huntr.com/bounties/53308220-8b2e-492f-b248-0985b7c2db61">https://huntr.com/bounties/53308220-8b2e-492f-b248-0985b7c2db61</a></li>
</ul>
<h3 id="cve-2024-0436">CVE-2024-0436</h3>
<h4 id="description-26">description</h4>
<p>Theoretically, it would be possible for an attacker to brute-force the password for an instance in single-user password protection mode via a timing attack given the linear nature of the <code>!==</code> used for comparison. The risk is minified by the additional overhead of the request, which varies in a non-constant nature making the attack less reliable to execute</p>
<h4 id="description-27">description</h4>
<p>从理论上讲，考虑到“！==”的线性性质，攻击者有可能在单用户密码保护模式下通过定时攻击强行破解实例的密码用于比较。请求的额外开销以非恒定的性质变化，使攻击执行起来不太可靠，从而降低了风险</p>
<table>
<thead>
<tr>
<th>cvss</th>
<th>epss</th>
<th>percentile</th>
</tr>
</thead>
<tbody>
<tr>
<td>7.1 HIGH</td>
<td>0.04%</td>
<td>6.87%</td>
</tr>
</tbody>
</table>
<h4 id="references-12">references</h4>
<ul>
<li><a href="https://github.com/mintplex-labs/anything-llm/commit/3c859ba3038121b67fb98e87dc52617fa27cbef0">https://github.com/mintplex-labs/anything-llm/commit/3c859ba3038121b67fb98e87dc52617fa27cbef0</a></li>
<li><a href="https://huntr.com/bounties/3e73cb96-c038-46a1-81b7-4d2215b36268">https://huntr.com/bounties/3e73cb96-c038-46a1-81b7-4d2215b36268</a></li>
</ul>
<h3 id="cve-2024-0439">CVE-2024-0439</h3>
<h4 id="description-28">description</h4>
<p>As a manager, you should not be able to modify a series of settings. In the UI this is indeed hidden as a convenience for the role since most managers would not be savvy enough to modify these settings. They can use their token to still modify those settings though through a standard HTTP request While this is not a critical vulnerability, it does indeed need to be patched to enforce the expected permission level.</p>
<h4 id="description-29">description</h4>
<p>作为管理者，您不应该能够修改一系列设置。在用户界面中，这确实是为了方便角色而隐藏的，因为大多数经理都不够精明，无法修改这些设置。尽管通过标准HTTP请求，他们仍然可以使用令牌修改这些设置。虽然这不是一个关键漏洞，但确实需要对其进行修补，以强制执行预期的权限级别。</p>
<table>
<thead>
<tr>
<th>cvss</th>
<th>epss</th>
<th>percentile</th>
</tr>
</thead>
<tbody>
<tr>
<td>7.1 HIGH</td>
<td>0.04%</td>
<td>6.87%</td>
</tr>
</tbody>
</table>
<h4 id="references-13">references</h4>
<ul>
<li><a href="https://github.com/mintplex-labs/anything-llm/commit/7200a06ef07d92eef5f3c4c8be29824aa001d688">https://github.com/mintplex-labs/anything-llm/commit/7200a06ef07d92eef5f3c4c8be29824aa001d688</a></li>
<li><a href="https://huntr.com/bounties/7fc1b78e-7faf-4f40-961d-61e53dac81ce">https://huntr.com/bounties/7fc1b78e-7faf-4f40-961d-61e53dac81ce</a></li>
</ul>
<h3 id="cve-2024-0440">CVE-2024-0440</h3>
<h4 id="description-30">description</h4>
<p>Attacker, with permission to submit a link or submits a link via POST to be collected that is using the file:// protocol can then introspect host files and other relatively stored files.</p>
<h4 id="description-31">description</h4>
<p>攻击者有权提交链接或通过POST提交使用file://协议收集的链接，然后可以内省主机文件和其他相对存储的文件。</p>
<table>
<thead>
<tr>
<th>cvss</th>
<th>epss</th>
<th>percentile</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>0.04%</td>
<td>6.87%</td>
</tr>
</tbody>
</table>
<h3 id="cve-2024-0455">CVE-2024-0455</h3>
<h4 id="description-32">description</h4>
<p>The inclusion of the web scraper for AnythingLLM means that any user with the proper authorization level (manager, admin, and when in single user) could put in the URL <code>http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance</code> which is a special IP and URL that resolves only when the request comes from within an EC2 instance. This would allow the user to see the connection/secret credentials for their specific instance and be able to manage it regardless of who deployed it. The user would have to have pre-existing knowledge of the hosting infra which the target instance is deployed on, but if sent - would resolve if on EC2 and the proper <code>iptable</code> or firewall rule is not configured for their setup.</p>
<h4 id="description-33">description</h4>
<p>AnythingLLM的web scraper的包含意味着任何具有适当授权级别的用户（管理员、管理员以及单个用户）都可以将URL“”http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance“”是一个特殊的IP和URL，只有当请求来自EC2实例时才能解析。这将允许用户查看其特定实例的连接/机密凭据，并能够对其进行管理，而不管是谁部署的。用户必须预先了解目标实例部署在其上的托管基础设施，但如果在EC2上，并且没有为其设置配置适当的“iptable”或防火墙规则，则如果发送，则会解决问题。</p>
<table>
<thead>
<tr>
<th>cvss</th>
<th>epss</th>
<th>percentile</th>
</tr>
</thead>
<tbody>
<tr>
<td>9.9 CRITICAL</td>
<td>0.04%</td>
<td>6.87%</td>
</tr>
</tbody>
</table>
<h4 id="references-14">references</h4>
<ul>
<li><a href="https://github.com/mintplex-labs/anything-llm/commit/b2b2c2afe15c48952d57b4d01e7108f9515c5f55">https://github.com/mintplex-labs/anything-llm/commit/b2b2c2afe15c48952d57b4d01e7108f9515c5f55</a></li>
<li><a href="https://huntr.com/bounties/07d83b49-7ebb-40d2-83fc-78381e3c5c9c">https://huntr.com/bounties/07d83b49-7ebb-40d2-83fc-78381e3c5c9c</a></li>
</ul>
<h3 id="cve-2024-0798">CVE-2024-0798</h3>
<h4 id="description-34">description</h4>
<p>A user with a <code>default</code> role given to them by the admin can sent <code>DELETE</code> HTTP requests to <code>remove-folder</code> and <code>remove-document</code> to delete folders and source files from the instance even when their role should explicitly not allow this action on the system.</p>
<h4 id="description-35">description</h4>
<p>具有管理员赋予的“默认”角色的用户可以向“删除文件夹”和“删除文档”发送“删除”HTTP请求，以从实例中删除文件夹和源文件，即使他们的角色明确不允许在系统上执行此操作。</p>
<table>
<thead>
<tr>
<th>cvss</th>
<th>epss</th>
<th>percentile</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>0.04%</td>
<td>6.87%</td>
</tr>
</tbody>
</table>
<h3 id="cve-2024-1875">CVE-2024-1875</h3>
<h4 id="description-36">description</h4>
<p>A vulnerability was found in SourceCodester Complaint Management System 1.0 and classified as critical. This issue affects some unknown processing of the file users/register-complaint.php of the component Lodge Complaint Section. The manipulation leads to unrestricted upload. The attack may be initiated remotely. The exploit has been disclosed to the public and may be used. The associated identifier of this vulnerability is VDB-254723.</p>
<h4 id="description-37">description</h4>
<p>在SourceCodester投诉管理系统1.0中发现一个漏洞，并将其归类为严重漏洞。此问题影响了对组件Lodge complaint Section的users/register-comment.php文件的一些未知处理。这种操作会导致不受限制的上传。攻击可以远程启动。该漏洞已向公众公开，并可能被利用。此漏洞的关联标识符为VDB-254723。</p>
<table>
<thead>
<tr>
<th>cvss</th>
<th>epss</th>
<th>percentile</th>
</tr>
</thead>
<tbody>
<tr>
<td>6.3 MEDIUM</td>
<td>0.04%</td>
<td>12.26%</td>
</tr>
</tbody>
</table>
<h4 id="references-15">references</h4>
<ul>
<li><a href="https://toradah.notion.site/Remote-Code-Execution-RCE-via-Unrestricted-File-Upload-6ed7ae9c833c4d8baaae7d64ae0c4a47?pvs=4">https://toradah.notion.site/Remote-Code-Execution-RCE-via-Unrestricted-File-Upload-6ed7ae9c833c4d8baaae7d64ae0c4a47?pvs=4</a></li>
<li><a href="https://vuldb.com/?ctiid.254723">https://vuldb.com/?ctiid.254723</a></li>
<li><a href="https://vuldb.com/?id.254723">https://vuldb.com/?id.254723</a></li>
</ul>
<h3 id="cve-2024-27350">CVE-2024-27350</h3>
<h4 id="description-38">description</h4>
<p>Amazon Fire OS 7 before 7.6.6.9 and 8 before 8.1.0.3 allows Fire TV applications to establish local ADB (Android Debug Bridge) connections. NOTE: some third parties dispute whether this has security relevance, because an ADB connection is only possible after the (non-default) ADB Debugging option is enabled, and after the initiator of that specific connection attempt has been approved via a full-screen prompt.</p>
<h4 id="description-39">description</h4>
<p>亚马逊Fire操作系统7.6.6.9之前的7和8.1.0.3之前的8允许Fire TV应用程序建立本地ADB（Android调试桥）连接。注：一些第三方对这是否具有安全相关性表示质疑，因为只有在启用（非默认）ADB调试选项后，以及在通过全屏提示批准特定连接尝试的发起人后，才能进行ADB连接。</p>
<table>
<thead>
<tr>
<th>cvss</th>
<th>epss</th>
<th>percentile</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>0.04%</td>
<td>12.26%</td>
</tr>
</tbody>
</table>
<h4 id="references-16">references</h4>
<ul>
<li><a href="https://developer.amazon.com/docs/fire-tv/fire-os-overview.html">https://developer.amazon.com/docs/fire-tv/fire-os-overview.html</a></li>
<li><a href="https://news.ycombinator.com/item?id=39496861">https://news.ycombinator.com/item?id=39496861</a></li>
<li><a href="https://www.aftvnews.com/amazon-blocks-long-running-fire-tv-capability-breaking-popular-apps-with-no-warning-and-giving-developers-the-runaround/">https://www.aftvnews.com/amazon-blocks-long-running-fire-tv-capability-breaking-popular-apps-with-no-warning-and-giving-developers-the-runaround/</a></li>
</ul>
<h3 id="cve-2024-27359">CVE-2024-27359</h3>
<h4 id="description-40">description</h4>
<p>Certain WithSecure products allow a Denial of Service because the engine scanner can go into an infinite loop when processing an archive file. This affects WithSecure Client Security 15, WithSecure Server Security 15, WithSecure Email and Server Security 15, WithSecure Elements Endpoint Protection 17 and later, WithSecure Client Security for Mac 15, WithSecure Elements Endpoint Protection for Mac 17 and later, WithSecure Linux Security 64 12.0, WithSecure Linux Protection 12.0, and WithSecure Atlant 1.0.35-1.</p>
<h4 id="description-41">description</h4>
<p>某些WithSecure产品允许拒绝服务，因为引擎扫描程序在处理存档文件时可能会进入无限循环。这会影响WithSecure Client Security 15、WithSecure Server Security 15、WithSecure Email and Server Security 15，WithSecure Elements Endpoint Protection 17及更高版本，WithSecure Client Protection for Mac 15，WithSecurity Elements Endpoints Protection for Mac 17及更新版本，WithSecurity Linux Security 64 12.0、WithSecure Linux Protection 12.0和WithSecure Atlant 1.0.35-1。</p>
<table>
<thead>
<tr>
<th>cvss</th>
<th>epss</th>
<th>percentile</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>0.04%</td>
<td>6.87%</td>
</tr>
</tbody>
</table>
<h4 id="references-17">references</h4>
<ul>
<li><a href="https://www.withsecure.com/en/support/security-advisories/cve-2034-n1">https://www.withsecure.com/en/support/security-advisories/cve-2034-n1</a></li>
</ul>
<!-- raw HTML omitted -->
<h2 id="modified_entries">Modified_entries</h2>
<h3 id="cve-2024-25189">CVE-2024-25189</h3>
<h4 id="description-42">description</h4>
<p>libjwt 1.15.3 uses strcmp (which is not constant time) to verify authentication, which makes it easier to bypass authentication via a timing side channel.</p>
<h4 id="description-43">description</h4>
<p>libjwt 1.15.3使用strcmp（不是恒定时间）来验证身份验证，这使得通过定时侧通道绕过身份验证变得更容易。</p>
<table>
<thead>
<tr>
<th>cvss</th>
<th>epss</th>
<th>percentile</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>0.11%</td>
<td>41.88%</td>
</tr>
</tbody>
</table>
<h4 id="references-18">references</h4>
<ul>
<li><a href="https://github.com/P3ngu1nW/CVE_Request/blob/main/benmcollins%3Alibjwt.md">https://github.com/P3ngu1nW/CVE_Request/blob/main/benmcollins%3Alibjwt.md</a></li>
<li><a href="https://lists.debian.org/debian-lts-announce/2024/02/msg00009.html">https://lists.debian.org/debian-lts-announce/2024/02/msg00009.html</a></li>
</ul>

      
      
      
    </article>
    


  </main>
  
  <nav class="pagination-single">
    
    
  </nav>


  
  <footer role="contentinfo">
    <div style="text-align:center;">
      
      
    </div>
  </footer>


</div>

<script src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>



</body>
</html>

